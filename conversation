Hola Grok, ¿me escuchas?

¡Sí, te escucho! ¿Qué tal, cómo puedo ayudarte hoy?

Más tarde va a haber una sesión de discovery para una aplicación bancaria de Java y estábamos de transferencia de conocimiento y estábamos pensando en algunas preguntas que pueden ser interesantes, básicamente todo lo que ve que tenga que ver con la construcción, el, la composición de esa aplicación eh y por supuesto la operación, ¿no? Eh, por ejemplo, qué frameworks utiliza, a qué bases de datos se conecta, cuántos usuarios simultáneos se conectan, quiénes son los usuarios, personas o sistemas y qué sistemas son, eh cuántas personas son, si tienen niveles de servicio ya acordados, cuáles es, son los sistemas de recuperación de desastre de continuidad de negocio que tienen establecidos, es una aplicación bancaria eh y, eh bueno, también cosas como eh cuáles son los modelos de disponibilidad que tiene la aplicación, cómo es que se despliega, está containerizada, corre en un orquestador o corre en una máquina virtual, etcétera. Aparte de todo esto, ¿qué consideras importante para la sesión de conocimiento? Porque la idea es que un grupo de personas tomen el soporte de esta aplicación.

¡Entendido! Estás preparando una sesión de discovery para una aplicación bancaria en Java y quieres asegurarte de cubrir todos los puntos clave para la transferencia de conocimiento. Además de lo que mencionaste, aquí van algunas preguntas y consideraciones importantes que podrías incluir para tener una visión completa de la construcción, composición y operación de la app. Voy a organizarlas en categorías para que sea más claro: ### Construcción de la aplicación - Arquitectura: ¿Cuál

10 web pages

Eh, no, yo no lo estoy preparando. Eh, va a haber una sesión y lo que lo que quiero preparar son las preguntas para poder hacer un buen, una buena absorción de ese conocimiento.

¡Ok, gracias por aclarar! Entonces, quieres armar una lista de preguntas clave para absorber bien el conocimiento en esa sesión de discovery para la aplicación bancaria en Java. Además de lo que ya mencionaste, aquí van algunas ideas adicionales para que saques el máximo provecho: 1. Arquitectura y diseño: ¿Cuál es la arquitectura general de la app? ¿Es monolítica, microservicios o algo híbrido? ¿Hay diagramas actualizados que muestren los componentes y cómo se relacionan? 2. Integraciones: ¿Con qué sistemas externos se conecta? ¿Usa APIs, colas de mensajes (como Kafka o RabbitMQ) o servicios de terceros? ¿Hay documentación de estas integraciones? 3. Seguridad: ¿Qué medidas de seguridad tiene implementadas? ¿Cómo manejan autenticación, autorización, cifrado de datos y cumplimiento normativo (como PCI-DSS para banca)? 4. Monitoreo y alertas: ¿Qué herramientas usan para monitorear el rendimiento y la salud de la app? ¿Tienen dashboards, logs centralizados o sistemas de alertas configurados? 5. Mantenimiento y soporte: ¿Quiénes están encargados actualmente del soporte? ¿Hay un equipo dedicado o es tercerizado? ¿Qué procesos siguen para resolver incidentes o bugs? 6. Ciclo de vida del desarrollo: ¿Cómo es el proceso de desarrollo y despliegue? ¿Usan CI/CD? ¿Qué herramientas de control de versiones (como Git) y pipelines tienen? 7. Escalabilidad: ¿Cómo maneja la app picos de carga? ¿Tiene autoescalado configurado? ¿Qué límites de capacidad han probado? 8. Documentación: ¿Qué documentación existe? ¿Manuales técnicos, guías de operación o runbooks? ¿Están actualizados? 9. Pruebas: ¿Qué estrategia de pruebas tienen? ¿Hacen pruebas unitarias, de integración, de carga? ¿Qué herramientas usan para esto? 10. Histórico y lecciones aprendidas: ¿Cuáles han sido los principales problemas o incidentes en el pasado? ¿Qué aprendieron y cómo lo resolvieron? Estas preguntas te ayudarán a tener una visión completa de la aplicación, desde su construcción hasta su operación, y a entender bien cómo soportarla. Si quieres, puedo ayudarte a priorizarlas o enfocarlas en algo más específico. ¿Qué te parece?

Puedes agregar y crear una lista con estas que tú creaste y las que yo te decía de continuidad de negocios eh si la aplicación es zonal o regional, si está containerizada, eh número de usuarios, puedes eh crear una lista de ya combinando todas estas preguntas, si está en la nube, etcétera.

¡Claro, vamos a combinar todo en una lista organizada de preguntas clave para la sesión de transferencia de conocimiento! Aquí tienes una lista unificada que incluye tus puntos y los que mencioné, enfocada en cubrir la construcción, composición y operación de la aplicación bancaria en Java: 1. Arquitectura y diseño: ¿Cuál es la arquitectura de la aplicación? ¿Es monolítica, microservicios o híbrida? ¿Hay diagramas actualizados de los componentes y sus relaciones? 2. Frameworks y tecnologías: ¿Qué frameworks utiliza la aplicación (por ejemplo, Spring, Hibernate)? ¿Qué versión de Java está en uso? 3. Bases de datos: ¿A qué bases de datos se conecta? ¿SQL o NoSQL? ¿Cuáles son los esquemas y cómo se gestionan? 4. Integraciones: ¿Con qué sistemas externos se conecta? ¿Usa APIs, colas de mensajes (como Kafka, RabbitMQ) o servicios de terceros? ¿Hay documentación de estas integraciones? 5. Usuarios: ¿Cuántos usuarios simultáneos soporta la aplicación? ¿Quiénes son los usuarios? ¿Personas, sistemas o ambos? Si son sistemas, ¿cuáles son? 6. Escalabilidad: ¿Cómo maneja la app picos de carga? ¿Tiene autoescalado configurado? ¿Qué límites de capacidad han probado? 7. Despliegue: ¿Cómo se despliega la aplicación? ¿Está containerizada (por ejemplo, Docker)? ¿Corre en un orquestador (como Kubernetes) o en máquinas virtuales? 8. Disponibilidad: ¿Cuáles son los modelos de disponibilidad de la aplicación? ¿Es zonal, regional o global? ¿Está alojada en la nube (AWS, Azure, GCP) o en infraestructura local? 9. Niveles de servicio: ¿Existen niveles de servicio (SLAs) acordados? ¿Cuáles son los objetivos de tiempo de actividad, tiempo de respuesta, etc.? 10. Continuidad de negocio y recuperación de desastres: ¿Qué sistemas de recuperación de desastres o continuidad de negocio están implementados? ¿Hay planes de respaldo o sitios secundarios? ¿Se han probado? 11. Seguridad: ¿Qué medidas de seguridad están implementadas? ¿Cómo se manejan autenticación, autorización, cifrado y cumplimiento normativo (como PCI-DSS)? 12. Monitoreo y alertas: ¿Qué herramientas se usan para monitorear rendimiento y salud? ¿Hay dashboards, logs centralizados o sistemas de alertas? 13. Mantenimiento y soporte: ¿Quién está a cargo del soporte actualmente? ¿Es un equipo interno o tercerizado? ¿Qué procesos se siguen para resolver incidentes? 14. Ciclo de vida del desarrollo: ¿Cómo es el proceso de desarrollo y despliegue? ¿Usan CI/CD? ¿Qué herramientas de control de versiones (como Git) y pipelines existen? 15. Pruebas: ¿Qué estrategia de pruebas tienen? ¿Hacen pruebas unitarias, de integración o de carga? ¿Qué herramientas usan? 16. Documentación: ¿Qué documentación existe? ¿Hay manuales técnicos, guías de operación o runbooks? ¿Están actualizados? 17. Histórico y lecciones aprendidas: ¿Cuáles han sido los principales incidentes en el pasado? ¿Cómo se resolvieron y qué se aprendió? Esta lista cubre todo lo que mencionaste (continuidad, usuarios, containerización, nube, etc.) y lo complementa con aspectos técnicos y operativos clave. Puedes usarla como guía en la sesión para asegurarte de no dejar nada fuera. Si quieres, puedo ayudarte a agruparlas por temas o priorizarlas para la sesión. ¿Algo más en lo que pueda ayudarte?

Aparte, aparte de todas estas preguntas, ¿consideras que hay algún aspecto adicional que sería importante cubrir?

¡Buena pregunta! Además de todo lo que ya cubrimos, hay un par de aspectos que podrían ser clave para asegurar una transición suave en el soporte de la aplicación bancaria. Aquí van algunas ideas adicionales: 1. Cultura y procesos del equipo: ¿Cómo es la dinámica del equipo que desarrolló o mantiene la app? ¿Hay reuniones regulares, como dailies o retros, que debas conocer? ¿Qué herramientas de colaboración usan (Jira, Confluence, Slack)? 2. Deuda técnica: ¿Hay deuda técnica conocida en la aplicación? ¿Qué componentes o áreas necesitan refactoring o mejoras urgentes? 3. Capacitación del equipo de soporte: ¿Qué nivel de conocimiento espera el equipo actual que tenga el nuevo equipo de soporte? ¿Hay planes para sesiones de capacitación o shadowing? 4. Dependencias externas: ¿Depende la app de licencias, servicios de terceros o contratos específicos que deban gestionarse? ¿Están documentados los costos asociados? 5. Roadmap futuro: ¿Hay planes de nuevas funcionalidades, migraciones o actualizaciones (como cambio de versión de Java o base de datos)? ¿Cuál es la visión a corto y largo plazo? Estos puntos te ayudarán a entender no solo la aplicación, sino también el contexto operativo y estratégico, lo cual es crucial para un soporte efectivo. ¿Quieres que profundice en alguno de estos o los integre a la lista anterior?

Eh, pensando en los errores que pueden ocurrir en una aplicación, muchas veces, bueno, yo estoy pensando en categorías generales, ¿no? Muchas veces puede ser en interacciones con terceros. Llega un parámetro mal a un API y esa API tiene lógica que trata de insertar en una base de datos y no se puede insertar porque el parámetro es incorrecto, porque está vacío, porque está nulo, etcétera. Ese es un tipo de error. Otro tipo de error es al llamar a un sistema de terceros que falla por sí solo. Entonces, esa falla del sistema de terceros produce un error en toda la lógica de negocios actual. ¿Qué otros tipos de fallas comunes podrías considerar que normalmente ocurren en este tipo de aplicaciones?

¡Entendido! Estás buscando identificar categorías generales de errores comunes en aplicaciones bancarias en Java, además de los problemas con interacciones de terceros que mencionaste. Aquí van algunas categorías de fallas típicas que suelen ocurrir en este tipo de aplicaciones, con un enfoque claro y conciso: 1. Errores de concurrencia: Cuando múltiples usuarios o procesos acceden simultáneamente a la aplicación, pueden surgir problemas como bloqueos (deadlocks), condiciones de carrera (race conditions) o inconsistencias en los datos, especialmente en transacciones bancarias donde la integridad es crítica. 2. Errores de configuración: Configuraciones incorrectas en el entorno (como parámetros de conexión a bases de datos, variables de entorno o archivos de propiedades) pueden causar fallos al iniciar la app o durante su ejecución. 3. Fallas de conectividad: Pérdida de conexión con bases de datos, servicios externos o redes, lo que puede interrumpir transacciones o procesos críticos, como la validación de pagos o transferencias. 4. Errores de validación de datos: Además de parámetros nulos o vacíos que mencionaste, pueden ocurrir problemas con formatos incorrectos (como fechas mal formadas) o datos que violan reglas de negocio (por ejemplo, montos negativos en transferencias). 5. Excepciones no manejadas: Errores en el código que no se capturan adecuadamente, como divisiones por cero, accesos a objetos nulos o desbordamientos de memoria, pueden hacer que la aplicación se caiga o devuelva respuestas inesperadas. 6. Problemas de rendimiento: La aplicación puede fallar bajo alta carga si no está optimizada, como tiempos de respuesta lentos, consultas a bases de datos mal diseñadas o consumo excesivo de recursos (CPU, memoria). 7. Errores de seguridad: Fallos relacionados con autenticación (tokens expirados), autorización (acceso a recursos no permitidos) o vulnerabilidades como inyecciones SQL o exposición de datos sensibles. 8. Fallas en la lógica de negocio: Errores en los cálculos o flujos de la aplicación, como redondeos incorrectos en transacciones financieras o flujos de aprobación mal implementados. 9. Problemas de despliegue: Errores durante la implementación, como versiones incompatibles de librerías, configuraciones de contenedores mal definidas o migraciones de bases de datos fallidas. 10. Errores de monitoreo o logging: Si el sistema no registra correctamente los errores o no tiene alertas configuradas, puede ser difícil identificar y resolver problemas rápidamente, lo que agrava el impacto. Estas categorías cubren los fallos más comunes en aplicaciones bancarias, considerando su complejidad y la criticidad de sus operaciones. Si quieres, puedo sugerir preguntas específicas para la sesión de discovery que ayuden a explorar cómo manejan estas fallas en la aplicación. ¿Te parece?

Sí.

¡Perfecto! Vamos a armar algunas preguntas específicas para la sesión de discovery que te ayuden a explorar cómo la aplicación bancaria en Java maneja las categorías de errores que mencionamos. Estas preguntas están pensadas para obtener información clave sobre la gestión de fallos y así facilitar la transición al equipo de soporte: 1. Errores de concurrencia: ¿Cómo maneja la aplicación transacciones simultáneas? ¿Usan mecanismos como bloqueos optimistas o pesimistas? ¿Han enfrentado deadlocks o race conditions? ¿Cómo los resolvieron? 2. Errores de configuración: ¿Cómo se gestionan las configuraciones de la aplicación? ¿Hay un sistema centralizado para variables de entorno o archivos de propiedades? ¿Qué problemas de configuración han encontrado antes? 3. Fallas de conectividad: ¿Qué mecanismos tienen para manejar caídas de conexión con bases de datos o servicios externos? ¿Usan reintentos automáticos o circuit breakers? 4. Errores de validación de datos: ¿Cómo valida la aplicación los datos de entrada, especialmente en APIs? ¿Qué pasa cuando llega un parámetro nulo, vacío o con formato incorrecto? ¿Tienen reglas de validación documentadas? 5. Excepciones no manejadas: ¿Cómo manejan excepciones inesperadas en el código? ¿Tienen un estándar para capturar y registrar errores? ¿Qué tan común es que la app se caiga por excepciones no controladas? 6. Problemas de rendimiento: ¿Han tenido cuellos de botella por alta carga? ¿Qué herramientas usan para identificar problemas de rendimiento? ¿Realizan pruebas de carga regularmente? 7. Errores de seguridad: ¿Qué mecanismos tienen para prevenir y detectar fallos de seguridad, como accesos no autorizados o inyecciones? ¿Cómo registran incidentes de seguridad? 8. Fallas en la lógica de negocio: ¿Han identificado errores en cálculos o flujos críticos, como en transferencias o reportes financieros? ¿Cómo los detectaron y corrigieron? 9. Problemas de despliegue: ¿Qué problemas han enfrentado durante despliegues? ¿Tienen rollback automático o procesos de recuperación si algo falla? 10. Errores de monitoreo o logging: ¿Qué herramientas usan para logs y monitoreo? ¿Cómo identifican la causa raíz de un error? ¿Tienen alertas configuradas para fallos críticos? Estas preguntas te ayudarán a entender cómo la aplicación aborda los errores más comunes y qué tan preparada está para manejarlos. También te darán una idea de las áreas problemáticas que el equipo de soporte deberá priorizar. ¿Quieres que ajuste alguna pregunta o agregue algo más?

El versionamiento semántico, por ejemplo, en Maven, cuando tienes versionamiento semántico es del, del POM, ¿no? Puede ser un WAR, puede ser un JAR, que tiene una versión. Pero también tienes un versionamiento semántico en Git. ¿Cómo se conectan los dos? Eh, ¿en qué momento se unen? ¿Es por una rama o...?

¡Buena pregunta! El versionamiento semántico en una aplicación Java, como mencionas, se maneja en dos niveles distintos: el del proyecto (por ejemplo, en el archivo POM de Maven, para un WAR o JAR) y el del control de versiones en Git. Vamos a desglosarlo para que quede claro cómo se conectan: 1. Versionamiento en Maven (POM): En el archivo pom.xml, la versión (como 1.2.3) sigue el estándar de versionamiento semántico (MAJOR.MINOR.PATCH). Esta versión define el entregable final (JAR, WAR, etc.) y se usa para identificar releases en el ciclo de vida del software. Por ejemplo, un cambio en MAJOR indica cambios no compatibles, MINOR para nuevas funcionalidades compatibles y PATCH para correcciones de bugs. 2. Versionamiento en Git: En Git, el versionamiento no es semántico por sí mismo, sino que se basa en commits, ramas y etiquetas (tags). Los desarrolladores suelen usar etiquetas (por ejemplo, v1.2.3) para marcar puntos específicos en la historia del repositorio que corresponden a releases. 3. Cómo se conectan: La conexión entre ambos ocurre principalmente en el proceso de construcción y release, a menudo automatizado mediante pipelines CI/CD. Aquí está cómo suelen unirse: - Ramas y estrategias: Normalmente, se usa una rama principal (como main o master) para el código estable y una rama como develop para desarrollo en curso. Cuando se decide hacer un release, se crea una etiqueta en Git (por ejemplo, v1.2.3) que corresponde a la versión definida en el pom.xml. - Pipeline CI/CD: En un pipeline (por ejemplo, con Jenkins, GitHub Actions o GitLab CI), el proceso de build toma el código de una rama o etiqueta específica, lee la versión del pom.xml y genera el artefacto (JAR/WAR) con esa versión. Si necesitas cambiar la versión, puedes actualizar el pom.xml manualmente o con herramientas como el plugin maven-release-plugin, que también crea la etiqueta en Git automáticamente. - Sincronización: La clave está en mantener la coherencia entre la versión del pom.xml y la etiqueta en Git. Por ejemplo, si el pom.xml dice 1.2.3, la etiqueta en Git debería ser v1.2.3. Esto suele gestionarse en el pipeline, donde el build valida que ambas versiones coincidan o actualiza una según la otra. 4. En qué momento se unen: La unión ocurre en el momento del release. Por ejemplo: - Trabajas en la rama develop, y cuando el código está listo, lo merges a main. - Actualizas la versión en el pom.xml (o el pipeline lo hace por ti). - Creas una etiqueta en Git (como v1.2.3) para marcar ese commit como un release. - El pipeline construye el artefacto y lo publica en un repositorio como Nexus o Artifactory con la versión del POM. 5. Buenas prácticas: - Usa herramientas como maven-release-plugin para automatizar la actualización de versiones en el POM y la creación de etiquetas en Git. - Mantén una convención clara para ramas (por ejemplo, feature/, release/, hotfix/) y etiqueta siempre los releases en Git. - Si usas ramas de release (como release/1.2.3), estas pueden servir como un punto intermedio para ajustes finales antes de etiquetar y actualizar el POM. En resumen, la versión del pom.xml y las etiquetas en Git se alinean en el proceso de release, normalmente gestionado por un pipeline CI/CD que garantiza que ambos reflejen la misma versión semántica. Si quieres, puedo detallar un ejemplo práctico de cómo configurar esto en un pipeline o profundizar en alguna herramienta específica. ¿Qué te parece?

Está muy interesante lo del ejemplo, nada más me gustaría agregar algo y es eh Docker, ¿no? Eh, Docker está finalmente sincronizado con las etiquetas de Git, ¿no? O sea, que finalmente viene de la versión, por ejemplo, del POM que se refleja en etiquetas de Git y Docker cuando crea una imagen son etiquetas que corresponden a esa misma versión semántica. ¿Es correcto?

¡Exacto, estás en lo correcto! Docker se integra perfectamente con el versionamiento semántico que viene del pom.xml y las etiquetas de Git, y todo se sincroniza en el proceso de construcción de la imagen. Vamos a aclarar cómo funciona y luego te doy un ejemplo práctico que incluye Docker, para que quede súper claro: 1. Sincronización del versionamiento: - Como mencionaste, la versión semántica definida en el pom.xml (por ejemplo, 1.2.3) se usa como base para el artefacto (JAR, WAR, etc.) que genera Maven. - En Git, cuando haces un release, creas una etiqueta (como v1.2.3) que corresponde a esa versión del pom.xml. - Cuando construyes una imagen de Docker, la etiqueta de la imagen suele reflejar esa misma versión semántica (por ejemplo, mi-app:1.2.3), asegurando consistencia entre el código, el artefacto y la imagen. 2. Cómo se conecta Docker: - Durante el proceso de build en un pipeline CI/CD, se usa el Dockerfile para crear la imagen. El pipeline toma el artefacto generado por Maven (con la versión del pom.xml) y lo incluye en la imagen. - Luego, al etiquetar la imagen de Docker (docker tag), se usa la misma versión del pom.xml o la etiqueta de Git (por ejemplo, mi-app:1.2.3). Esto asegura que la imagen de Docker esté alineada con el código y el artefacto. - Es común también agregar una etiqueta adicional como latest para la versión más reciente, aunque se recomienda usar siempre versiones específicas para trazabilidad. 3. Ejemplo práctico: Imagina que tienes una aplicación bancaria en Java. Aquí está cómo se conectan los tres elementos en un pipeline típico: - Paso 1: Código y versión en Maven - Tu pom.xml tiene 1.2.3. - El equipo termina una nueva funcionalidad, y estás listo para un release. - Paso 2: Etiqueta en Git - Haces commit en la rama develop, luego merges a main. - Usas un plugin como maven-release-plugin para actualizar el pom.xml (por ejemplo, de 1.2.3-SNAPSHOT a 1.2.3) y creas una etiqueta en Git: git tag v1.2.3. - Paso 3: Construcción del artefacto - El pipeline CI/CD (por ejemplo, GitHub Actions) detecta la etiqueta v1.2.3, ejecuta mvn package y genera un artefacto (mi-app-1.2.3.jar). - El artefacto se sube a un repositorio como Nexus. - Paso 4: Construcción de la imagen Docker - El pipeline usa un Dockerfile que copia el artefacto (mi-app-1.2.3.jar) en la imagen. - Ejecuta docker build -t mi-app:1.2.3 . para crear la imagen con la misma versión. - Opcionalmente, agrega docker tag mi-app:1.2.3 mi-app:latest para marcar la versión más reciente. - La imagen se sube a un registro como Docker Hub o un registro privado (docker push mi-app:1.2.3). - Paso 5: Despliegue - La imagen mi-app:1.2.3 se despliega en un orquestador como Kubernetes, usando la versión específica para asegurar trazabilidad. 4. Punto clave: La sincronización ocurre porque el pipeline toma la versión del pom.xml (o la etiqueta de Git) y la aplica a la imagen de Docker. Esto se configura en el script del pipeline, donde lees la versión (por ejemplo, con mvn help:evaluate

Hola.

¡Hola! Entonces, hablando de cómo se conectan

Hola. Eh, una pregunta, eh, cuando hablas del pipeline, que bueno, la la la parte del pipeline, pipeline que mencionas dentro de todo este proceso que estás explicando, eh, ¿es Jenkins?

¡Hola! El pipeline que mencioné puede ser con Jenkins, sí, pero no necesariamente. El concepto de pipeline CI/CD es independiente de la herramienta; puede implementarse con Jenkins, GitHub Actions, GitLab CI, CircleCI, o cualquier otra plataforma de integración y despliegue continuo. Como mencionaste Jenkins, voy a explicar cómo encaja en este proceso y mantengo la idea general por si usas otra herramienta. En el contexto del versionamiento semántico y la integración con Maven, Git y Docker que estábamos discutiendo, Jenkins (o cualquier herramienta CI/CD) actúa como el orquestador que automatiza los pasos. Aquí va cómo Jenkins manejaría el flujo: 1. Trigger del pipeline: Configuras un job en Jenkins que se activa al detectar un cambio en Git, como un push a la rama main o una nueva etiqueta (por ejemplo, v1.2.3). 2. Lectura de la versión: Jenkins ejecuta un comando como mvn help:evaluate -Dexpression=project.version para obtener la versión del pom.xml (por ejemplo, 1.2.3). 3. Construcción del artefacto: Usa mvn package para generar el JAR o WAR, que se sube a un repositorio como Nexus. 4. Creación de la imagen Docker: Jenkins ejecuta docker build -t mi-app:1.2.3 . usando la versión obtenida del pom.xml o la etiqueta de Git, y luego sube la imagen a un registro con docker push mi-app:1.2.3. 5. Etiquetado en Git: Si usas algo como maven-release-plugin, Jenkins puede crear la etiqueta en Git (por ejemplo, git tag v1.2.3) y hacer push al repositorio. 6. Despliegue: Jenkins puede orquestar el despliegue de la imagen mi-app:1.2.3 a un entorno como Kubernetes. Un ejemplo simplificado de un script de Jenkins (en un Jenkinsfile) sería: groovy pipeline { agent any stages { stage('Checkout') { steps { git 'https://github.com/tu-repo/mi-app.git' } } stage('Build') { steps { sh 'mvn clean package' } } stage('Docker Build') { steps { sh 'docker build -t mi-app:${POM_VERSION} .' sh 'docker push mi-app:${POM_VERSION}' } } } } Si no usas Jenkins, el mismo flujo aplica en otras herramientas. Por ejemplo, en GitHub Actions usarías un workflow YAML, pero la lógica es similar: clonas el repo, lees la versión, construyes el artefacto, creas la imagen Docker y la despliegas. ¿Usas Jenkins específicamente o alguna otra herramienta? Si me das más contexto, puedo personalizar el ejemplo. ¿Qué te parece?
